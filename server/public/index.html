<!doctype html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tikeo - Gestion des frais</title>

  <style>
    :root{
      --primary:#2563eb;
      --primary-hover:#1d4ed8;
      --success:#059669;
      --error:#dc2626;

      --bg:#f8fafc;
      --card-bg:#ffffff;
      --text-main:#0f172a;
      --text-muted:#64748b;
      --border:#e2e8f0;

      --radius:14px;
      --shadow:0 10px 22px rgba(15, 23, 42, .08);
      --shadow-soft:0 4px 10px rgba(15, 23, 42, .06);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:"Segoe UI", system-ui, -apple-system, sans-serif;
      background:var(--bg);
      color:var(--text-main);
      line-height:1.5;
    }

    .container{
      max-width:760px;
      margin:0 auto;
      padding:20px;
      padding-bottom:80px;
    }

    center img{
      max-width:140px;
      margin:10px auto 6px;
      filter:drop-shadow(0 8px 12px rgba(15,23,42,.10));
    }

    h1{
      font-size:1.55rem;
      font-weight:900;
      text-align:center;
      margin:8px 0 22px;
      letter-spacing:-.02em;
    }

    .card{
      background:var(--card-bg);
      padding:22px;
      margin-bottom:18px;
      border-radius:var(--radius);
      border:1px solid var(--border);
      box-shadow:var(--shadow-soft);
    }

    .card h3{
      margin:0 0 14px;
      font-size:1.05rem;
      font-weight:800;
      letter-spacing:-.01em;
    }

    label{
      display:block;
      margin-bottom:14px;
      font-size:.9rem;
      font-weight:700;
      color:var(--text-main);
    }

    .hint{
      font-size:.82rem;
      color:var(--text-muted);
      margin-top:-8px;
      margin-bottom:12px;
    }

    input, select, textarea{
      width:100%;
      margin-top:6px;
      padding:12px 12px;
      border-radius:10px;
      border:1px solid var(--border);
      font-size:16px;
      background:#fcfcfd;
      outline:none;
      transition:border-color .15s ease, box-shadow .15s ease, transform .05s ease;
    }

    input:focus, select:focus, textarea:focus{
      border-color:rgba(37,99,235,.55);
      box-shadow:0 0 0 4px rgba(37,99,235,.14);
    }

    input[readonly]{
      background:#f1f5f9;
      color:#0f172a;
    }

    textarea{
      min-height:180px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .row{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
    }
    .row > div{
      flex:1;
      min-width:170px;
    }

    button{
      width:100%;
      padding:14px 16px;
      margin-top:10px;
      background:var(--primary);
      color:#fff;
      border:none;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:.98rem;
      box-shadow:var(--shadow);
      transition:transform .06s ease, background .15s ease, box-shadow .15s ease, filter .15s ease;
      touch-action:manipulation;
    }
    button:hover{ background:var(--primary-hover); }
    button:active{ transform:translateY(1px); box-shadow:var(--shadow-soft); }

    #openDossier{ background:var(--success) !important; }
    #openDossier:hover{ filter:brightness(.95); }

    .error, .success{
      padding:12px;
      border-radius:12px;
      margin-top:14px;
      font-size:.88rem;
      font-weight:650;
      white-space:pre-wrap;
      border:1px solid transparent;
    }
    .error{ background:#fee2e2; color:var(--error); border-color:#fecaca; }
    .success{ background:#ecfdf5; color:var(--success); border-color:#d1fae5; }
    .error:empty, .success:empty, .hidden{ display:none; }

    .file-wrap{ margin-top:8px; }
    .file-drop{
      display:block;
      width:100%;
      border:1.5px dashed #cbd5e1;
      border-radius:14px;
      padding:14px;
      background:linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
      box-shadow:0 1px 0 rgba(15,23,42,.03);
      cursor:pointer;
      transition:border-color .15s ease, box-shadow .15s ease, transform .05s ease;
      user-select:none;
    }
    .file-drop:hover{
      border-color:rgba(37,99,235,.55);
      box-shadow:0 0 0 4px rgba(37,99,235,.10);
    }
    .file-drop strong{ display:block; font-weight:850; margin-bottom:4px; }
    .file-drop span{ color:var(--text-muted); font-size:.86rem; }
    input[type="file"]{
      padding:0;
      border:none;
      background:transparent;
    }

    button[disabled]{
      opacity:.7;
      cursor:not-allowed;
      filter:saturate(.9);
    }

    .title-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:14px;
    }
    .title-row h3{ margin:0; }

    .icon-btn{
      width:40px;
      height:40px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow:var(--shadow-soft);
      padding:0;
      color:#000;
      touch-action:manipulation;
    }
    .icon-btn:hover{
      box-shadow:0 0 0 4px rgba(37,99,235,.10);
      border-color:rgba(37,99,235,.55);
      color:#000;
    }
    .icon-btn svg{ width:20px; height:20px; }

    @media (max-width:520px){
      .container{ padding:14px; }
      .card{ padding:18px; }
      .row > div{ min-width:100%; }
      h1{ font-size:1.35rem; }
    }

    /* Masquer input file natif */
    #fileInput{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
      opacity:0;
    }

    /* Debug masqu√© en mobile */
    @media (max-width:520px){
      #debugCard{ display:none !important; }
    }

    /* =========================
       ‚úÖ MODAL SCAN NON-BLOQUANT
       - Overlay cliquable UNIQUEMENT sur le panneau (pas sur tout l'√©cran)
       - Le fond est "pass-through" : n'intercepte pas les clics (pointer-events:none)
       - Option : clic sur fond pour fermer (activable via data-close-backdrop)
       ========================= */
    #scanModal.hidden{ display:none !important; }

    #scanModal{
      position:fixed;
      inset:0;
      z-index:9999;
      /* IMPORTANT: ne bloque pas le front */
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #scanBackdrop{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.72);
      /* IMPORTANT: ne bloque pas le front */
      pointer-events:none;
    }

    /* Le panneau, lui, est interactif */
    #scanPanel{
      position:relative;
      width:min(96vw,520px);
      background:var(--card-bg);
      border-radius:14px;
      padding:12px;
      border:1px solid var(--border);
      /* IMPORTANT: seul le panneau capte les events */
      pointer-events:auto;
      box-shadow:var(--shadow);
    }

    /* Pour autoriser la fermeture en cliquant hors panneau :
       on active pointer-events sur le backdrop */
    #scanModal[data-close-backdrop="1"] #scanBackdrop{
      pointer-events:auto;
    }

    /* Video container */
    #scanViewport{
      position:relative;
      width:100%;
      aspect-ratio:3/4;
      background:#000;
      border-radius:12px;
      overflow:hidden;
    }
    #scanVideo{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover;
    }
    #scanOverlay{
      position:absolute; inset:0; width:100%; height:100%;
      /* overlay de dessin, doit rester interactif pour rien (juste dessin) */
      pointer-events:none;
    }

    .scan-actions{
      display:flex;
      gap:10px;
      margin-top:10px;
    }

    /* Mode sombre auto */
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b1220;
        --card-bg:#0f172a;
        --text-main:#e5e7eb;
        --text-muted:#94a3b8;
        --border:#1f2a44;

        --shadow:0 10px 22px rgba(0,0,0,.35);
        --shadow-soft:0 6px 14px rgba(0,0,0,.28);
      }

      body{ background:var(--bg); color:var(--text-main); }

      input, select, textarea{
        background:#0b1326;
        color:var(--text-main);
        border-color:var(--border);
      }

      input[readonly]{ background:#0b1326; }

      .card{
        background:var(--card-bg);
        border-color:var(--border);
      }

      .file-drop{
        background:linear-gradient(180deg, #0f172a 0%, #0b1326 100%);
        border-color:#334155;
      }

      .icon-btn{
        background:#0f172a;
        border-color:var(--border);
        color:#e5e7eb;
      }

      .error{ background:rgba(220,38,38,.18); border-color:rgba(220,38,38,.35); color:#fecaca; }
      .success{ background:rgba(5,150,105,.18); border-color:rgba(5,150,105,.35); color:#a7f3d0; }
    }
  </style>
</head>

<body>
<div class="container">
  <center><img src="http://www.image-heberg.fr/files/1772025987602134325.png" alt="Tikeo.png" /></center>
  <h1 id="pageTitle">Gestion des frais</h1>

  <!-- ADMIN -->
  <div id="adminBlock" class="card hidden">
    <h3>Admin</h3>

    <label>CNX base URL (ex: https://isuiteacd.suiteexpert.fr/cnx/api)
      <input id="baseUrl" placeholder="https://isuiteacd.suiteexpert.fr/cnx/api">
    </label>

    <div class="row">
      <div>
        <label>Identifiant
          <input id="identifiant" placeholder="...">
        </label>
      </div>
      <div>
        <label>Mot de passe
          <input id="motdepasse" type="password" placeholder="...">
        </label>
      </div>
    </div>

    <label>Code dossier (ex: DA_CONSEIL)
      <input id="codeDossier" placeholder="Code dossier Comptabilit√©">
    </label>
    <div class="hint">Requis : l‚Äôupload GED est bloqu√© si vide.</div>

    <button id="saveAdmin">Enregistrer</button>
    <button id="openDossier" style="background:#28a745;margin-left:8px">Ouvrir dossier</button>

    <button id="backHome" style="background:#64748b">Retour accueil</button>

    <button id="resetTicketCounter" style="background:#ef4444">RAZ compteur tickets</button>

    <div id="adminErr" class="error"></div>
    <div id="adminOk" class="success"></div>
  </div>

  <!-- USER -->
  <div id="userBlock" class="hidden">

    <div class="card">
      <div class="title-row">
        <h3>1Ô∏è‚É£ Scannez le ticket ou importez le PDF</h3>

        <button class="icon-btn" id="goAdmin" type="button" aria-label="R√©glages">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
            <path d="M19.4 15a7.9 7.9 0 0 0 .1-2l2-1.2-2-3.4-2.3.6a8 8 0 0 0-1.7-1l-.3-2.4H10.8L10.5 7a8 8 0 0 0-1.7 1L6.5 7.4l-2 3.4 2 1.2a7.9 7.9 0 0 0 .1 2l-2 1.2 2 3.4 2.3-.6a8 8 0 0 0 1.7 1l.3 2.4h4.4l.3-2.4a8 8 0 0 0 1.7-1l2.3.6 2-3.4-2-1.2z"/>
          </svg>
        </button>
      </div>

      <label>Code dossier comptable
        <input id="codeDossierView" readonly>
      </label>

      <label>Ticket √† envoyer (Par photo en mobile)</label>

      <div class="file-wrap">
        <label class="file-drop" for="fileInput">
          <strong>Choisir un PDF ou prendre une photo</strong>
          <span>Mobile : la cam√©ra s‚Äôouvre automatiquement (si autoris√©e).</span>
        </label>
        <input type="file" id="fileInput" accept="application/pdf,image/*" capture="environment">
      </div>

      <!-- ‚úÖ Mode scan live -->
      <button id="openScan" type="button" style="background:#0ea5e9">üì∑ Mode scan (auto)</button>

      <button id="uploadGed">Envoyer le ticket</button>

      <div id="gedErr" class="error"></div>
      <div id="gedOk" class="success"></div>

      <input id="referenceGedId" type="hidden">
    </div>

    <div class="card">
      <h3>2Ô∏è‚É£ √âcriture comptable</h3>

      <div class="row">
        <div>
          <label>Journal
            <input id="journal" value="AC">
          </label>
        </div>
        <div>
          <label>Fournisseur
            <select id="compteFournisseur">
              <option value="FREPAS">FREPAS</option>
              <option value="FCARBU">FCARBU</option>
              <option value="FPARKING">FPARKING</option>
              <option value="FPEAGE">FPEAGE</option>
              <option value="FDIVERS" selected>FDIVERS</option>
            </select>
          </label>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Cat√©gorie d√©penses
            <select id="categorie"></select>
          </label>
        </div>
        <div>
          <label>TVA (%)
            <select id="tvaRate"></select>
          </label>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Date ticket (YYYY-MM-DD)
            <input id="dateTicket" placeholder="2025-01-02">
          </label>
        </div>
        <div>
          <label>Num√©ro ticket
            <input id="numeroTicket" placeholder="(auto si vide √† la validation)">
          </label>
        </div>
      </div>

      <label>Raison sociale (libell√©)
        <input id="raisonSociale" placeholder="ex: L'ATELIER DE LA PAIX">
      </label>

      <div class="row">
        <div>
          <label>Montant TTC
            <input id="ttc" inputmode="decimal" placeholder="25,50">
          </label>
        </div>
        <div>
          <label>Montant HT
            <input id="ht" inputmode="decimal" placeholder="23,18">
          </label>
        </div>
      </div>

      <label>Montant TVA
        <input id="tvaMontant" inputmode="decimal" placeholder="2,32">
      </label>

      <button id="submit">Envoyer l‚Äô√©criture</button>
      <div id="err" class="error"></div>
      <div id="ok" class="success"></div>
    </div>

    <div id="debugCard" class="card hidden">
      <h3>Debug (/?debug=1)</h3>
      <textarea id="debugOut" readonly></textarea>
    </div>
  </div>
</div>

<!-- ‚úÖ Modal scan live (non-bloquant) -->
<div id="scanModal" class="hidden" aria-hidden="true">
  <div id="scanBackdrop" aria-hidden="true"></div>

  <div id="scanPanel" role="dialog" aria-modal="false" aria-label="Scan ticket">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px">
      <strong>Scan ticket</strong>
      <button id="closeScan" type="button" style="width:auto; padding:8px 10px; background:#64748b">Fermer</button>
    </div>

    <div id="scanViewport">
      <video id="scanVideo" playsinline autoplay muted></video>
      <canvas id="scanOverlay"></canvas>
    </div>

    <div class="scan-actions">
      <button id="scanSnap" type="button" style="background:#22c55e">Capturer</button>
      <button id="scanRetry" type="button" style="background:#f59e0b">Reprendre</button>
    </div>

    <div id="scanMsg" class="hint" style="margin-top:8px">
      Place le ticket dans le cadre, capture auto quand stable‚Ä¶
    </div>
  </div>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
  const el = (id) => document.getElementById(id);
  const qs = new URLSearchParams(location.search);
  const isAdmin = qs.get("admin") === "1";
  const isDebug = qs.get("debug") === "1";

  const CATEGORIES = [
    { key: "petites_fournitures", label: "Petites fournitures et entretien", vat: ["20","10"] },
    { key: "papeterie", label: "Papeterie", vat: ["20"] },
    { key: "carburant", label: "Carburant", vat: ["20"] },
    { key: "repas_pro", label: "Repas pro", vat: ["10"] },
    { key: "repas", label: "Repas (TVA 0%)", vat: ["0"] },
    { key: "peages", label: "P√©ages", vat: ["20"] },
    { key: "parking", label: "Parking", vat: ["20"] }
  ];

  function toNumOrNull(v){
    const s = String(v || "").trim().replace(",", ".");
    if (!s) return null;
    const x = Number(s);
    return Number.isFinite(x) ? x : null;
  }

  function setSelect(selectEl, value){
    if (!value) return;
    const opt = [...selectEl.options].find(o => o.value === value);
    if (opt) selectEl.value = value;
  }

  function fillCategories(){
    el("categorie").innerHTML = CATEGORIES.map(c => `<option value="${c.key}">${c.label}</option>`).join("");
  }

  function fillVatForCurrentCategory(){
    const cat = CATEGORIES.find(c => c.key === el("categorie").value);
    const allowed = cat ? cat.vat : ["20","10","0"];
    const current = el("tvaRate").value;
    el("tvaRate").innerHTML = allowed.map(v => `<option value="${v}">${v}%</option>`).join("");
    if (allowed.includes(current)) el("tvaRate").value = current;
  }

  async function loadCodeDossier(){
    try{
      const resp = await fetch("/api/admin/public");
      const out = await resp.json();
      el("codeDossierView").value = out.codeDossier || "";
      return out.codeDossier || "";
    }catch{
      el("codeDossierView").value = "";
      return "";
    }
  }

  /* ===== Compteur ticket : NE BOUGE QUE SI validation OK ET ticket auto ===== */
  function getTicketCounter() {
    const key = "ticket_counter_T";
    const v = Number(localStorage.getItem(key) || "0");
    return Number.isFinite(v) && v >= 0 ? v : 0;
  }

  function peekNextTicketNumber() {
    const next = getTicketCounter() + 1;
    return "T" + String(next).padStart(4, "0");
  }

  // Commit UNIQUEMENT quand l'√©criture est valid√©e (succ√®s serveur)
  function commitTicketNumberUsed(num) {
    const m = /^T(\d{4,})$/i.exec(String(num || "").trim());
    if (!m) return;
    const used = Number(m[1]);
    if (!Number.isFinite(used)) return;
    localStorage.setItem("ticket_counter_T", String(used));
  }

  function waitForOpenCV(timeoutMs = 12000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function poll(){
        if (window.cv && cv.Mat) return resolve();
        if (Date.now() - start > timeoutMs) return reject(new Error("OpenCV.js non charg√© (r√©seau ?)"));
        setTimeout(poll, 60);
      })();
    });
  }

  function orderCorners(pts) {
    const sum = pts.map(p => p.x + p.y);
    const diff = pts.map(p => p.x - p.y);
    const tl = pts[sum.indexOf(Math.min(...sum))];
    const br = pts[sum.indexOf(Math.max(...sum))];
    const tr = pts[diff.indexOf(Math.max(...diff))];
    const bl = pts[diff.indexOf(Math.min(...diff))];
    return [tl, tr, br, bl];
  }

  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  /* Fallback minAreaRect -> 4 points */
  function rectPointsFromMinAreaRect(cnt){
    const rr = cv.minAreaRect(cnt);
    const cx = rr.center.x, cy = rr.center.y;
    const w = rr.size.width, h = rr.size.height;
    const a = (rr.angle || 0) * Math.PI / 180;

    const cos = Math.cos(a), sin = Math.sin(a);
    const hw = w / 2, hh = h / 2;

    const corners = [
      {x: -hw, y: -hh},
      {x:  hw, y: -hh},
      {x:  hw, y:  hh},
      {x: -hw, y:  hh},
    ];

    return corners.map(p => ({
      x: cx + (p.x * cos - p.y * sin),
      y: cy + (p.x * sin + p.y * cos),
    }));
  }

  /* ====== Scan live ====== */
  let scanStream = null;
  let scanRunning = false;
  let scanCapturedPdf = null;
  let scanCapturedName = "photo_ticket.pdf";

  const scan = {
    video: null,
    overlay: null,
    msg: null,
    lastQuad: null,
    stableCount: 0,
    rafId: 0,
    downW: 720,
    stableFrames: 10,
    jitterPx: 14,
    minAreaRatio: 0.20,
  };

  function showScanModal(show){
    const m = el("scanModal");
    if (show){
      m.classList.remove("hidden");
      m.setAttribute("aria-hidden", "false");
      // emp√™che le scroll du body SANS bloquer les clics (overlay pass-through)
      document.body.style.overflow = "hidden";
    } else {
      m.classList.add("hidden");
      m.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
    }
  }

  // ‚úÖ fermeture optionnelle au clic sur le backdrop
  el("scanModal").dataset.closeBackdrop = "1";
  el("scanBackdrop").addEventListener("click", () => stopScanMode());

  async function openScanMode(){
    scanCapturedPdf = null;

    scan.video = el("scanVideo");
    scan.overlay = el("scanOverlay");
    scan.msg = el("scanMsg");
    scan.lastQuad = null;
    scan.stableCount = 0;

    showScanModal(true);

    scanStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } },
      audio: false
    });

    scan.video.srcObject = scanStream;
    await scan.video.play();

    resizeOverlayToVideo();

    scanRunning = true;
    scan.msg.textContent = "Recherche du ticket‚Ä¶";
    scan.rafId = requestAnimationFrame(scanLoop);
  }

  function stopScanMode(){
    scanRunning = false;
    if (scan.rafId) cancelAnimationFrame(scan.rafId);
    scan.rafId = 0;

    if (scanStream){
      scanStream.getTracks().forEach(t => t.stop());
      scanStream = null;
    }
    showScanModal(false);
  }

  function resizeOverlayToVideo(){
    const v = scan.video;
    const c = scan.overlay;
    if (!v || !c) return;
    const vw = v.videoWidth || 720;
    const vh = v.videoHeight || 1280;
    c.width = vw;
    c.height = vh;
  }

  function drawOverlay(quad, statusText){
    const ctx = scan.overlay.getContext("2d");
    const w = scan.overlay.width, h = scan.overlay.height;
    ctx.clearRect(0,0,w,h);

    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.fillRect(0,0,w,h);

    if (!quad){
      scan.msg.textContent = statusText || "Aucun contour net‚Ä¶";
      return;
    }

    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.moveTo(quad[0].x, quad[0].y);
    for (let i=1;i<4;i++) ctx.lineTo(quad[i].x, quad[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";

    ctx.lineWidth = 6;
    ctx.strokeStyle = (scan.stableCount >= scan.stableFrames) ? "rgba(34,197,94,.95)" : "rgba(14,165,233,.95)";
    ctx.beginPath();
    ctx.moveTo(quad[0].x, quad[0].y);
    for (let i=1;i<4;i++) ctx.lineTo(quad[i].x, quad[i].y);
    ctx.closePath();
    ctx.stroke();

    scan.msg.textContent = statusText || (scan.stableCount >= scan.stableFrames
      ? "Stable ‚úì Capture‚Ä¶"
      : `Stabilisation‚Ä¶ (${scan.stableCount}/${scan.stableFrames})`);
  }

  function quadArea(quad){
    let a = 0;
    for (let i=0;i<4;i++){
      const p = quad[i], q = quad[(i+1)%4];
      a += p.x*q.y - q.x*p.y;
    }
    return Math.abs(a)/2;
  }

  function quadJitter(q1, q2){
    if (!q1 || !q2) return 1e9;
    let s = 0;
    for (let i=0;i<4;i++){
      const dx = q1[i].x - q2[i].x;
      const dy = q1[i].y - q2[i].y;
      s += Math.hypot(dx,dy);
    }
    return s/4;
  }

  function emaQuad(prev, next, alpha=0.35){
    if (!prev) return next;
    return prev.map((p,i)=>({
      x: p.x*(1-alpha) + next[i].x*alpha,
      y: p.y*(1-alpha) + next[i].y*alpha
    }));
  }

  function detectQuadLiveFromVideoFrame(){
    const v = scan.video;
    const vw = v.videoWidth, vh = v.videoHeight;
    if (!vw || !vh) return null;

    const targetW = scan.downW;
    const r = targetW / vw;
    const dw = targetW;
    const dh = Math.round(vh * r);

    const tmp = document.createElement("canvas");
    tmp.width = dw; tmp.height = dh;
    tmp.getContext("2d").drawImage(v, 0,0, dw,dh);

    const src = cv.imread(tmp);
    const gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
    const blur = new cv.Mat();
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

    const thr = new cv.Mat();
    cv.adaptiveThreshold(blur, thr, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 31, 10);
    const inv = new cv.Mat();
    cv.bitwise_not(thr, inv);

    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5,5));
    const morphed = new cv.Mat();
    cv.morphologyEx(inv, morphed, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 2);

    const edges = new cv.Mat();
    cv.Canny(morphed, edges, 60, 180);

    const contours = new cv.MatVector();
    const hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bestCnt = null;
    let bestArea = 0;
    for (let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const area = cv.contourArea(cnt);
      if (area > bestArea){
        bestArea = area;
        if (bestCnt) bestCnt.delete();
        bestCnt = cnt.clone();
      }
      cnt.delete();
    }

    src.delete(); gray.delete(); blur.delete(); thr.delete(); inv.delete();
    kernel.delete(); morphed.delete(); edges.delete(); contours.delete(); hierarchy.delete();

    if (!bestCnt) return null;

    const minArea = (dw*dh) * scan.minAreaRatio;
    if (bestArea < minArea){
      bestCnt.delete();
      return null;
    }

    const pts = rectPointsFromMinAreaRect(bestCnt);
    bestCnt.delete();

    const scaleBack = vw / dw;
    const quad = orderCorners(pts.map(p => ({ x: p.x*scaleBack, y: p.y*scaleBack })));
    return quad;
  }

  // ====== PDF build (identique logique, sans modifier back) ======
  function strToBytes(s) { return new TextEncoder().encode(s); }

  function canvasToJpegBytes(canvas, quality = 0.86) {
    const dataUrl = canvas.toDataURL("image/jpeg", quality);
    const base64 = dataUrl.split(",")[1];
    const bin = atob(base64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return { bytes, w: canvas.width, h: canvas.height };
  }

  function jpegToPdfBlob(jpegBytes, imgW, imgH) {
    const pageW = 595, pageH = 842;
    const margin = 24;
    const boxW = pageW - 2*margin;
    const boxH = pageH - 2*margin;

    const imgRatio = imgW / imgH;
    let drawW = boxW;
    let drawH = Math.round(drawW / imgRatio);
    if (drawH > boxH) { drawH = boxH; drawW = Math.round(drawH * imgRatio); }
    const x = Math.round((pageW - drawW) / 2);
    const y = Math.round((pageH - drawH) / 2);

    const chunks = [];
    const objOffsets = [0];
    let cursor = 0;

    function addChunk(s) { const b = strToBytes(s); chunks.push(b); cursor += b.length; }
    function addBin(u8) { chunks.push(u8); cursor += u8.length; }
    function markObj() { objOffsets.push(cursor); }

    addChunk("%PDF-1.4\n%√¢√£√è√ì\n");

    markObj(); addChunk("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
    markObj(); addChunk("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
    markObj(); addChunk(
      `3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${pageW} ${pageH}] ` +
      `/Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`
    );

    markObj();
    addChunk(
      `4 0 obj\n<< /Type /XObject /Subtype /Image /Name /Im0 /Width ${imgW} /Height ${imgH} ` +
      `/ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`
    );
    addBin(jpegBytes);
    addChunk("\nendstream\nendobj\n");

    const content = `q\n${drawW} 0 0 ${drawH} ${x} ${y} cm\n/Im0 Do\nQ\n`;
    const contentBytes = strToBytes(content);

    markObj();
    addChunk(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
    addBin(contentBytes);
    addChunk("\nendstream\nendobj\n");

    const xrefPos = cursor;
    addChunk("xref\n0 6\n0000000000 65535 f \n");
    for (let i = 1; i <= 5; i++) addChunk(String(objOffsets[i]).padStart(10, "0") + " 00000 n \n");
    addChunk(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefPos}\n%%EOF\n`);

    return new Blob(chunks, { type: "application/pdf" });
  }

  function enhanceDocumentCanvas(canvas){
    const src = cv.imread(canvas);
    const gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

    const blur = new cv.Mat();
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

    const thr = new cv.Mat();
    cv.adaptiveThreshold(
      blur, thr, 255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY,
      31,
      10
    );

    const out = new cv.Mat();
    cv.cvtColor(thr, out, cv.COLOR_GRAY2RGBA, 0);

    const outCanvas = document.createElement("canvas");
    outCanvas.width = canvas.width;
    outCanvas.height = canvas.height;
    cv.imshow(outCanvas, out);

    src.delete(); gray.delete(); blur.delete(); thr.delete(); out.delete();
    return outCanvas;
  }

  function autoCropTicketCanvas(canvas, whiteThreshold = 245, margin = 8){
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const w = canvas.width, h = canvas.height;
    const img = ctx.getImageData(0,0,w,h).data;

    let minX = w, minY = h, maxX = -1, maxY = -1;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x)*4;
        const r = img[i], g = img[i+1], b = img[i+2];
        if (r < whiteThreshold || g < whiteThreshold || b < whiteThreshold){
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }
    if (maxX < 0) return canvas;

    minX = clamp(minX - margin, 0, w-1);
    minY = clamp(minY - margin, 0, h-1);
    maxX = clamp(maxX + margin, 0, w-1);
    maxY = clamp(maxY + margin, 0, h-1);

    const cw = maxX - minX + 1;
    const ch = maxY - minY + 1;
    if (cw < w*0.55 || ch < h*0.55) return canvas;

    const out = document.createElement("canvas");
    out.width = cw; out.height = ch;
    out.getContext("2d").drawImage(canvas, minX, minY, cw, ch, 0, 0, cw, ch);
    return out;
  }

  async function captureAndBuildPdfFromVideo(quadVideoCoords){
    const v = scan.video;
    const vw = v.videoWidth, vh = v.videoHeight;

    const baseCanvas = document.createElement("canvas");
    baseCanvas.width = vw; baseCanvas.height = vh;
    baseCanvas.getContext("2d").drawImage(v, 0,0, vw,vh);

    const [tl, tr, br, bl] = quadVideoCoords;
    const widthA = Math.hypot(br.x-bl.x, br.y-bl.y);
    const widthB = Math.hypot(tr.x-tl.x, tr.y-tl.y);
    const heightA = Math.hypot(tr.x-br.x, tr.y-br.y);
    const heightB = Math.hypot(tl.x-bl.x, tl.y-bl.y);

    let outW = Math.max(1, Math.round(Math.max(widthA, widthB)));
    let outH = Math.max(1, Math.round(Math.max(heightA, heightB)));
    if (outW > 2200){ const rr = 2200/outW; outW = Math.round(outW*rr); outH = Math.round(outH*rr); }

    const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y
    ]);
    const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      0, 0, outW-1, 0, outW-1, outH-1, 0, outH-1
    ]);

    const src = cv.imread(baseCanvas);
    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const warped = new cv.Mat();
    cv.warpPerspective(src, warped, M, new cv.Size(outW, outH), cv.INTER_LINEAR, cv.BORDER_REPLICATE);

    const warpedCanvas = document.createElement("canvas");
    warpedCanvas.width = outW; warpedCanvas.height = outH;
    cv.imshow(warpedCanvas, warped);

    src.delete(); srcTri.delete(); dstTri.delete(); M.delete(); warped.delete();

    const enhanced = enhanceDocumentCanvas(warpedCanvas);
    const cropped = autoCropTicketCanvas(enhanced, 245, 10);

    const { bytes, w, h } = canvasToJpegBytes(cropped, 0.86);
    scanCapturedPdf = jpegToPdfBlob(bytes, w, h);
    scanCapturedName = "photo_ticket.pdf";
  }

  async function scanLoop(){
    if (!scanRunning) return;

    if (!window.cv || !cv.Mat){
      drawOverlay(null, "OpenCV.js non pr√™t‚Ä¶");
      scan.rafId = requestAnimationFrame(scanLoop);
      return;
    }

    if (scan.overlay.width !== scan.video.videoWidth) resizeOverlayToVideo();

    const quad = detectQuadLiveFromVideoFrame();

    if (!quad){
      scan.lastQuad = null;
      scan.stableCount = 0;
      drawOverlay(null, "Ajuste le ticket dans le champ‚Ä¶");
      scan.rafId = requestAnimationFrame(scanLoop);
      return;
    }

    const smooth = emaQuad(scan.lastQuad, quad, 0.35);
    const jit = quadJitter(scan.lastQuad, smooth);

    const area = quadArea(smooth);
    const frameArea = scan.video.videoWidth * scan.video.videoHeight;
    const areaOk = area > frameArea * scan.minAreaRatio;

    const stable = areaOk && jit < scan.jitterPx;

    scan.stableCount = stable ? (scan.stableCount + 1) : 0;
    scan.lastQuad = smooth;

    drawOverlay(smooth);

    if (scan.stableCount >= scan.stableFrames){
      scanRunning = false;
      try{
        await captureAndBuildPdfFromVideo(smooth);
        drawOverlay(smooth, "Capture OK ‚úì");
        scan.msg.textContent = "Capture OK ‚úì Tu peux fermer et envoyer.";
      }catch(e){
        scan.msg.textContent = "Erreur capture: " + String(e.message || e);
        scanRunning = true;
        scan.stableCount = 0;
      }
    }

    scan.rafId = requestAnimationFrame(scanLoop);
  }

  function setBtnLoading(btn, isLoading, textLoading) {
    if (!btn) return;
    if (isLoading) {
      btn.dataset._txt = btn.textContent;
      btn.textContent = textLoading || "Traitement...";
      btn.disabled = true;
    } else {
      btn.textContent = btn.dataset._txt || btn.textContent;
      btn.disabled = false;
      delete btn.dataset._txt;
    }
  }

  function scheduleRefreshIn5s() {
    setTimeout(() => location.reload(), 5000);
  }

  // ===========================
  // UI scan handlers
  // ===========================
  el("openScan").addEventListener("click", async () => {
    el("gedErr").textContent = "";
    try{
      await waitForOpenCV();
      await openScanMode();
    }catch(e){
      el("gedErr").textContent = "Cam√©ra impossible : " + String(e.message || e);
      stopScanMode();
    }
  });

  el("closeScan").addEventListener("click", () => stopScanMode());

  el("scanRetry").addEventListener("click", () => {
    if (!scanStream) return;
    scanCapturedPdf = null;
    scan.lastQuad = null;
    scan.stableCount = 0;
    scanRunning = true;
    scan.rafId = requestAnimationFrame(scanLoop);
    el("scanMsg").textContent = "Recherche du ticket‚Ä¶";
  });

  el("scanSnap").addEventListener("click", async () => {
    if (!scan.lastQuad){
      el("scanMsg").textContent = "Aucun ticket d√©tect√©.";
      return;
    }
    try{
      await captureAndBuildPdfFromVideo(scan.lastQuad);
      el("scanMsg").textContent = "Capture OK ‚úì";
      drawOverlay(scan.lastQuad, "Capture OK ‚úì");
    }catch(e){
      el("scanMsg").textContent = "Erreur capture: " + String(e.message || e);
    }
  });

  // stop cam on navigation away
  window.addEventListener("beforeunload", () => {
    try { stopScanMode(); } catch {}
  });

  // ===========================
  // App main
  // ===========================
  if (isAdmin) {
    el("pageTitle").textContent = "Admin";
    el("adminBlock").classList.remove("hidden");

    el("backHome").addEventListener("click", () => {
      window.location.href = "/?";
    });

    el("resetTicketCounter").addEventListener("click", () => {
      el("adminErr").textContent = "";
      el("adminOk").textContent = "";
      try{
        if (!confirm("Remettre le compteur tickets √† z√©ro ? (Prochain ticket : T0001)")) return;
        localStorage.setItem("ticket_counter_T", "0");
        el("adminOk").textContent = "OK ‚Äî compteur tickets remis √† z√©ro (prochain : T0001).";
      }catch(e){
        el("adminErr").textContent = "Erreur RAZ compteur : " + String(e.message || e);
      }
    });

    el("saveAdmin").addEventListener("click", async () => {
      el("adminErr").textContent = "";
      el("adminOk").textContent = "";

      const payload = {
        baseUrl: el("baseUrl").value.trim(),
        identifiant: el("identifiant").value.trim(),
        motdepasse: el("motdepasse").value,
        codeDossier: el("codeDossier").value.trim()
      };

      setBtnLoading(el("saveAdmin"), true, "Enregistrement...");
      try {
        const resp = await fetch("/api/admin/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const out = await resp.json();
        if (!resp.ok) throw new Error(out.error || "Erreur");
        el("adminOk").textContent = "OK ‚Äî enregistr√©.";
      } catch (e) {
        el("adminErr").textContent = String(e.message || e);
      } finally {
        setBtnLoading(el("saveAdmin"), false);
      }
    });

    el("openDossier").addEventListener("click", async () => {
      el("adminErr").textContent = "";
      el("adminOk").textContent = "";

      const codeDossier = el("codeDossier").value.trim();
      if (!codeDossier) { el("adminErr").textContent = "Code dossier obligatoire."; return; }

      setBtnLoading(el("openDossier"), true, "Ouverture...");
      try {
        const resp = await fetch("/api/cnx/session-dossier", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ codeDossier })
        });
        const out = await resp.json();
        if (!resp.ok) throw new Error(out.error || "Erreur");
        el("adminOk").textContent = "OK ‚Äî dossier ouvert.";
      } catch (e) {
        el("adminErr").textContent = String(e.message || e);
      } finally {
        setBtnLoading(el("openDossier"), false);
      }
    });

  } else {
    el("userBlock").classList.remove("hidden");
    if (isDebug) el("debugCard").classList.remove("hidden");

    el("goAdmin").addEventListener("click", () => {
      window.location.href = "/?admin=1";
    });

    fillCategories();
    fillVatForCurrentCategory();
    el("categorie").addEventListener("change", () => fillVatForCurrentCategory());

    (async () => {
      const cd = await loadCodeDossier();
      if (!cd) el("gedErr").textContent = "Code dossier non configur√©. Cliquez sur l‚Äôic√¥ne r√©glages.";
    })();

    el("uploadGed").addEventListener("click", async () => {
      el("gedErr").textContent = "";
      el("gedOk").textContent = "";
      el("err").textContent = "";
      el("ok").textContent = "";
      if (isDebug) el("debugOut").value = "";

      const codeDossier = (el("codeDossierView").value || "").trim();
      if (!codeDossier) {
        el("gedErr").textContent = "Upload bloqu√© : code dossier manquant. Cliquez sur l‚Äôic√¥ne r√©glages.";
        return;
      }

      const file = el("fileInput").files[0];
      const hasScanPdf = !!scanCapturedPdf;

      if (!file && !hasScanPdf) { el("gedErr").textContent = "Choisis un PDF / photo ou utilise Mode scan."; return; }

      let pdfBlob = null;
      let filename = "ticket.pdf";

      setBtnLoading(el("uploadGed"), true, "Analyse / OCR...");
      try {
        if (hasScanPdf) {
          pdfBlob = scanCapturedPdf;
          filename = scanCapturedName || "photo_ticket.pdf";
        } else {
          const isPdf = file.type === "application/pdf" || (file.name || "").toLowerCase().endsWith(".pdf");
          const isImg = (file.type || "").startsWith("image/");

          if (isPdf) {
            pdfBlob = file;
            filename = file.name || "ticket.pdf";
          } else if (isImg) {
            throw new Error("Pour les images, utilise Mode scan (auto) ou convertis en PDF.");
          } else {
            throw new Error("Format non support√©. Utilise PDF ou Mode scan.");
          }
        }

        const form = new FormData();
        form.append("pdf", pdfBlob, filename);

        const resp = await fetch("/api/ged/upload", { method: "POST", body: form });
        const out = await resp.json();
        if (!resp.ok) throw new Error(out.error || "Erreur upload/OCR");

        el("referenceGedId").value = out.gedId;

        const ex = out.extraction || {};
        if (ex.date_document) el("dateTicket").value = ex.date_document;
        if (ex.raison_sociale) el("raisonSociale").value = ex.raison_sociale;

        if (ex.numero_ticket) el("numeroTicket").value = ex.numero_ticket;
        else el("numeroTicket").value = "";

        if (typeof ex.montant_ttc === "number") el("ttc").value = String(ex.montant_ttc).replace(".", ",");
        if (typeof ex.montant_ht === "number") el("ht").value = String(ex.montant_ht).replace(".", ",");
        if (typeof ex.montant_tva === "number") el("tvaMontant").value = String(ex.montant_tva).replace(".", ",");

        const sug = out.suggestion || {};
        if (sug.categorie_ui) setSelect(el("categorie"), sug.categorie_ui);
        fillVatForCurrentCategory();
        if (sug.tva_rate) setSelect(el("tvaRate"), sug.tva_rate);
        if (sug.compteF) setSelect(el("compteFournisseur"), sug.compteF);

        const num = String(el("numeroTicket").value || "").trim();
        el("gedOk").textContent = num ? ("OK ‚Äî Ticket charg√©. N¬∞ ticket : " + num) : "OK ‚Äî Ticket charg√©. N¬∞ ticket non d√©tect√©.";

        if (isDebug) el("debugOut").value = JSON.stringify(out, null, 2);
      } catch (e) {
        el("gedErr").textContent = String(e.message || e);
      } finally {
        setBtnLoading(el("uploadGed"), false);
      }
    });

    el("submit").addEventListener("click", async () => {
      el("err").textContent = "";
      el("ok").textContent = "";
      if (isDebug) el("debugOut").value = "";

      const referenceGedId = (el("referenceGedId").value || "").trim();
      if (!referenceGedId) {
        el("err").textContent = "Envoie d'abord le ticket (√âtape 1).";
        return;
      }

      const existing = String(el("numeroTicket").value || "").trim();
      const wasAuto = !existing;
      const numeroTicket = existing || peekNextTicketNumber();
      if (wasAuto) el("numeroTicket").value = numeroTicket;

      const meta = {
        journal: (el("journal").value || "").trim(),
        compteFournisseur: el("compteFournisseur").value,
        referenceGedId,
        categorie_ui: el("categorie").value,
        tva_rate: el("tvaRate").value,
        date_ticket: (el("dateTicket").value || "").trim(),
        numero_ticket: numeroTicket,
        raison_sociale: (el("raisonSociale").value || "").trim(),
        montant_ttc: toNumOrNull(el("ttc").value),
        ht: toNumOrNull(el("ht").value),
        tva_montant: toNumOrNull(el("tvaMontant").value)
      };

      const form = new FormData();
      form.append("meta", JSON.stringify(meta));

      setBtnLoading(el("submit"), true, "Envoi...");
      try {
        const resp = await fetch("/api/receipts/submit", { method: "POST", body: form });
        const out = await resp.json();
        if (!resp.ok) throw new Error(out.error || "Erreur envoi √©criture");

        if (wasAuto) commitTicketNumberUsed(numeroTicket);

        el("ok").textContent = "‚úÖ √âcriture envoy√©e. Rafra√Æchissement dans 5 secondes‚Ä¶";
        el("err").textContent = "";
        if (isDebug) el("debugOut").value = JSON.stringify(out, null, 2);

        scheduleRefreshIn5s();
      } catch (e) {
        el("err").textContent = "‚ùå " + String(e.message || e) + "\nRafra√Æchissement dans 5 secondes‚Ä¶";
        el("ok").textContent = "";
        scheduleRefreshIn5s();
      } finally {
        setBtnLoading(el("submit"), false);
      }
    });
  }
</script>
</body>
</html>
